<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ESP32VGA: FabGL::VGAControllerClass Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ESP32VGA
   </div>
   <div id="projectbrief">ESP32 VGA Controller and Graphics Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>FabGL</b></li><li class="navelem"><a class="el" href="class_fab_g_l_1_1_v_g_a_controller_class.html">VGAControllerClass</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_fab_g_l_1_1_v_g_a_controller_class-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">FabGL::VGAControllerClass Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents the VGA controller.  
 <a href="class_fab_g_l_1_1_v_g_a_controller_class.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="vgacontroller_8h_source.html">vgacontroller.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aade3e715b1c95b0b96d694fd55baece9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_fab_g_l_1_1_v_g_a_controller_class.html#aade3e715b1c95b0b96d694fd55baece9">begin</a> (gpio_num_t redGPIO, gpio_num_t greenGPIO, gpio_num_t blueGPIO, gpio_num_t HSyncGPIO, gpio_num_t VSyncGPIO)</td></tr>
<tr class="memdesc:aade3e715b1c95b0b96d694fd55baece9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the 8 colors (5 GPIOs) initializer.  <a href="#aade3e715b1c95b0b96d694fd55baece9">More...</a><br /></td></tr>
<tr class="separator:aade3e715b1c95b0b96d694fd55baece9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45fc8bdf74aa6bc15c475dde12ba0ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_fab_g_l_1_1_v_g_a_controller_class.html#ab45fc8bdf74aa6bc15c475dde12ba0ec">begin</a> (gpio_num_t red1GPIO, gpio_num_t red0GPIO, gpio_num_t green1GPIO, gpio_num_t green0GPIO, gpio_num_t blue1GPIO, gpio_num_t blue0GPIO, gpio_num_t HSyncGPIO, gpio_num_t VSyncGPIO)</td></tr>
<tr class="memdesc:ab45fc8bdf74aa6bc15c475dde12ba0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the 64 colors (8 GPIOs) initializer.  <a href="#ab45fc8bdf74aa6bc15c475dde12ba0ec">More...</a><br /></td></tr>
<tr class="separator:ab45fc8bdf74aa6bc15c475dde12ba0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91562139b5d73c2a7b7dcd43fd0a96d5"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_fab_g_l_1_1_v_g_a_controller_class.html#a91562139b5d73c2a7b7dcd43fd0a96d5">getBitsPerChannel</a> ()</td></tr>
<tr class="memdesc:a91562139b5d73c2a7b7dcd43fd0a96d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of bits allocated for each channel.  <a href="#a91562139b5d73c2a7b7dcd43fd0a96d5">More...</a><br /></td></tr>
<tr class="separator:a91562139b5d73c2a7b7dcd43fd0a96d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70582ae68f10c17fec24cda63f433ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_fab_g_l_1_1_v_g_a_controller_class.html#aa70582ae68f10c17fec24cda63f433ba">setResolution</a> (char const *modeline, int viewPortWidth=-1, int viewPortHeight=-1, bool doubleBuffered=false)</td></tr>
<tr class="memdesc:aa70582ae68f10c17fec24cda63f433ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set current resolution using linux-like modeline.  <a href="#aa70582ae68f10c17fec24cda63f433ba">More...</a><br /></td></tr>
<tr class="separator:aa70582ae68f10c17fec24cda63f433ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7eae8c450eccb9231bbb70e0bbf8831"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_fab_g_l_1_1_v_g_a_controller_class.html#ae7eae8c450eccb9231bbb70e0bbf8831">getScreenWidth</a> ()</td></tr>
<tr class="memdesc:ae7eae8c450eccb9231bbb70e0bbf8831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the screen width in pixels.  <a href="#ae7eae8c450eccb9231bbb70e0bbf8831">More...</a><br /></td></tr>
<tr class="separator:ae7eae8c450eccb9231bbb70e0bbf8831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a459bde05feea992889fb874435b5baa7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_fab_g_l_1_1_v_g_a_controller_class.html#a459bde05feea992889fb874435b5baa7">getScreenHeight</a> ()</td></tr>
<tr class="memdesc:a459bde05feea992889fb874435b5baa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the screen height in pixels.  <a href="#a459bde05feea992889fb874435b5baa7">More...</a><br /></td></tr>
<tr class="separator:a459bde05feea992889fb874435b5baa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52445643b3d2a4e1485c2fe2a5218f4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_fab_g_l_1_1_v_g_a_controller_class.html#af52445643b3d2a4e1485c2fe2a5218f4">getViewPortCol</a> ()</td></tr>
<tr class="memdesc:af52445643b3d2a4e1485c2fe2a5218f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return horizontal position of the viewport.  <a href="#af52445643b3d2a4e1485c2fe2a5218f4">More...</a><br /></td></tr>
<tr class="separator:af52445643b3d2a4e1485c2fe2a5218f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b2078e925299261ea9e7a3116352c5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_fab_g_l_1_1_v_g_a_controller_class.html#ad1b2078e925299261ea9e7a3116352c5">getViewPortRow</a> ()</td></tr>
<tr class="memdesc:ad1b2078e925299261ea9e7a3116352c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return vertical position of the viewport.  <a href="#ad1b2078e925299261ea9e7a3116352c5">More...</a><br /></td></tr>
<tr class="separator:ad1b2078e925299261ea9e7a3116352c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c11001fa49ef4f326f4ed400ed4895"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_fab_g_l_1_1_v_g_a_controller_class.html#a66c11001fa49ef4f326f4ed400ed4895">getViewPortWidth</a> ()</td></tr>
<tr class="memdesc:a66c11001fa49ef4f326f4ed400ed4895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return horizontal size of the viewport.  <a href="#a66c11001fa49ef4f326f4ed400ed4895">More...</a><br /></td></tr>
<tr class="separator:a66c11001fa49ef4f326f4ed400ed4895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab199d37c94991eb5b133c1b3ad45ec9c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_fab_g_l_1_1_v_g_a_controller_class.html#ab199d37c94991eb5b133c1b3ad45ec9c">getViewPortHeight</a> ()</td></tr>
<tr class="memdesc:ab199d37c94991eb5b133c1b3ad45ec9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return vertical size of the viewport.  <a href="#ab199d37c94991eb5b133c1b3ad45ec9c">More...</a><br /></td></tr>
<tr class="separator:ab199d37c94991eb5b133c1b3ad45ec9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c07cf7f184101d20a642b8c7cb8eb2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_fab_g_l_1_1_v_g_a_controller_class.html#a58c07cf7f184101d20a642b8c7cb8eb2">enableBackgroundPrimitiveExecution</a> (bool value)</td></tr>
<tr class="memdesc:a58c07cf7f184101d20a642b8c7cb8eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable drawings inside vertical retracing time.  <a href="#a58c07cf7f184101d20a642b8c7cb8eb2">More...</a><br /></td></tr>
<tr class="separator:a58c07cf7f184101d20a642b8c7cb8eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2488e30e07c7c6b90d7b0c92e53e913"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_fab_g_l_1_1_v_g_a_controller_class.html#af2488e30e07c7c6b90d7b0c92e53e913">suspendBackgroundPrimitiveExecution</a> ()</td></tr>
<tr class="memdesc:af2488e30e07c7c6b90d7b0c92e53e913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspend drawings.  <a href="#af2488e30e07c7c6b90d7b0c92e53e913">More...</a><br /></td></tr>
<tr class="separator:af2488e30e07c7c6b90d7b0c92e53e913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6784d28b04bd726e1d3bd34153b93aa9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_fab_g_l_1_1_v_g_a_controller_class.html#a6784d28b04bd726e1d3bd34153b93aa9">resumeBackgroundPrimitiveExecution</a> ()</td></tr>
<tr class="memdesc:a6784d28b04bd726e1d3bd34153b93aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume drawings after <a class="el" href="class_fab_g_l_1_1_v_g_a_controller_class.html#af2488e30e07c7c6b90d7b0c92e53e913" title="Suspend drawings. ">suspendBackgroundPrimitiveExecution()</a>.  <a href="#a6784d28b04bd726e1d3bd34153b93aa9">More...</a><br /></td></tr>
<tr class="separator:a6784d28b04bd726e1d3bd34153b93aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d19331fea4f141cab7b942b7d524fe4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_fab_g_l_1_1_v_g_a_controller_class.html#a7d19331fea4f141cab7b942b7d524fe4">processPrimitives</a> ()</td></tr>
<tr class="memdesc:a7d19331fea4f141cab7b942b7d524fe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw immediately all primitives in the queue.  <a href="#a7d19331fea4f141cab7b942b7d524fe4">More...</a><br /></td></tr>
<tr class="separator:a7d19331fea4f141cab7b942b7d524fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9cf1e40864d5a4d5242e0e76c54b81a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_fab_g_l_1_1_v_g_a_controller_class.html#ab9cf1e40864d5a4d5242e0e76c54b81a">moveScreen</a> (int16_t offsetX, int16_t offsetY)</td></tr>
<tr class="memdesc:ab9cf1e40864d5a4d5242e0e76c54b81a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move screen by specified horizontal and vertical offset.  <a href="#ab9cf1e40864d5a4d5242e0e76c54b81a">More...</a><br /></td></tr>
<tr class="separator:ab9cf1e40864d5a4d5242e0e76c54b81a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c1029eb0a46d49c80ce53abd4bbab9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_fab_g_l_1_1_v_g_a_controller_class.html#a75c1029eb0a46d49c80ce53abd4bbab9">shrinkScreen</a> (int shrinkX, int shrinkY)</td></tr>
<tr class="memdesc:a75c1029eb0a46d49c80ce53abd4bbab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce or expands screen size by the specified horizontal and vertical offset.  <a href="#a75c1029eb0a46d49c80ce53abd4bbab9">More...</a><br /></td></tr>
<tr class="separator:a75c1029eb0a46d49c80ce53abd4bbab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc5057bd666f81c640d375caed99eda"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4dc5057bd666f81c640d375caed99eda"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_fab_g_l_1_1_v_g_a_controller_class.html#a4dc5057bd666f81c640d375caed99eda">setSprites</a> (T *sprites, int count)</td></tr>
<tr class="memdesc:a4dc5057bd666f81c640d375caed99eda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the list of active sprites.  <a href="#a4dc5057bd666f81c640d375caed99eda">More...</a><br /></td></tr>
<tr class="separator:a4dc5057bd666f81c640d375caed99eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa329b92c25878731b603c9ae4fd69b4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_fab_g_l_1_1_v_g_a_controller_class.html#aa329b92c25878731b603c9ae4fd69b4b">removeSprites</a> ()</td></tr>
<tr class="memdesc:aa329b92c25878731b603c9ae4fd69b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty the list of active sprites.  <a href="#aa329b92c25878731b603c9ae4fd69b4b">More...</a><br /></td></tr>
<tr class="separator:aa329b92c25878731b603c9ae4fd69b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cbf7054fcf1f829e8327d2c2fc18b03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_fab_g_l_1_1_v_g_a_controller_class.html#a6cbf7054fcf1f829e8327d2c2fc18b03">refreshSprites</a> ()</td></tr>
<tr class="memdesc:a6cbf7054fcf1f829e8327d2c2fc18b03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force the sprites to be updated.  <a href="#a6cbf7054fcf1f829e8327d2c2fc18b03">More...</a><br /></td></tr>
<tr class="separator:a6cbf7054fcf1f829e8327d2c2fc18b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01955a85d46edd00b0503c7f2a0b8fb1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_fab_g_l_1_1_v_g_a_controller_class.html#a01955a85d46edd00b0503c7f2a0b8fb1">isDoubleBuffered</a> ()</td></tr>
<tr class="memdesc:a01955a85d46edd00b0503c7f2a0b8fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <a class="el" href="class_fab_g_l_1_1_v_g_a_controller_class.html" title="Represents the VGA controller. ">VGAControllerClass</a> is on double buffered mode.  <a href="#a01955a85d46edd00b0503c7f2a0b8fb1">More...</a><br /></td></tr>
<tr class="separator:a01955a85d46edd00b0503c7f2a0b8fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents the VGA controller. </p>
<p>Use this class to set screen resolution and to associate VGA signals to ESP32 GPIO outputs.</p>
<p>This example initializes VGA Controller with 8 colors (5 GPIOs used) and 640x350 resolution: </p><pre class="fragment">// Assign GPIO22 to Red, GPIO21 to Green, GPIO19 to Blue, GPIO18 to HSync and GPIO5 to VSync
VGAController.begin(GPIO_NUM_22, GPIO_NUM_21, GPIO_NUM_19, GPIO_NUM_18, GPIO_NUM_5);

// Set 640x350@70Hz resolution
VGAController.setResolution(VGA_640x350_70Hz);
</pre><p>This example initializes VGA Controller with 64 colors (8 GPIOs used) and 640x350 resolution: </p><pre class="fragment">// Assign GPIO22 and GPIO_NUM_21 to Red, GPIO_NUM_19 and GPIO_NUM_18 to Green, GPIO_NUM_5 and GPIO_NUM_4 to Blue, GPIO_NUM_23 to HSync and GPIO_NUM_15 to VSync
VGAController.begin(GPIO_NUM_22, GPIO_NUM_21, GPIO_NUM_19, GPIO_NUM_18, GPIO_NUM_5, GPIO_NUM_4, GPIO_NUM_23, GPIO_NUM_15);

// Set 640x350@70Hz resolution
VGAController.setResolution(VGA_640x350_70Hz);</pre> </div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aade3e715b1c95b0b96d694fd55baece9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aade3e715b1c95b0b96d694fd55baece9">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FabGL::VGAControllerClass::begin </td>
          <td>(</td>
          <td class="paramtype">gpio_num_t&#160;</td>
          <td class="paramname"><em>redGPIO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gpio_num_t&#160;</td>
          <td class="paramname"><em>greenGPIO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gpio_num_t&#160;</td>
          <td class="paramname"><em>blueGPIO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gpio_num_t&#160;</td>
          <td class="paramname"><em>HSyncGPIO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gpio_num_t&#160;</td>
          <td class="paramname"><em>VSyncGPIO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the 8 colors (5 GPIOs) initializer. </p>
<p>One GPIO per channel, plus horizontal and vertical sync signals.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">redGPIO</td><td>GPIO to use for red channel. </td></tr>
    <tr><td class="paramname">greenGPIO</td><td>GPIO to use for green channel. </td></tr>
    <tr><td class="paramname">blueGPIO</td><td>GPIO to use for blue channel. </td></tr>
    <tr><td class="paramname">HSyncGPIO</td><td>GPIO to use for horizontal sync signal. </td></tr>
    <tr><td class="paramname">VSyncGPIO</td><td>GPIO to use for vertical sync signal.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><pre class="fragment">// Use GPIO 22 for red, GPIO 21 for green, GPIO 19 for blue, GPIO 18 for HSync and GPIO 5 for VSync
VGAController.begin(GPIO_NUM_22, GPIO_NUM_21, GPIO_NUM_19, GPIO_NUM_18, GPIO_NUM_5);</pre> 
</div>
</div>
<a id="ab45fc8bdf74aa6bc15c475dde12ba0ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab45fc8bdf74aa6bc15c475dde12ba0ec">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FabGL::VGAControllerClass::begin </td>
          <td>(</td>
          <td class="paramtype">gpio_num_t&#160;</td>
          <td class="paramname"><em>red1GPIO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gpio_num_t&#160;</td>
          <td class="paramname"><em>red0GPIO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gpio_num_t&#160;</td>
          <td class="paramname"><em>green1GPIO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gpio_num_t&#160;</td>
          <td class="paramname"><em>green0GPIO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gpio_num_t&#160;</td>
          <td class="paramname"><em>blue1GPIO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gpio_num_t&#160;</td>
          <td class="paramname"><em>blue0GPIO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gpio_num_t&#160;</td>
          <td class="paramname"><em>HSyncGPIO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gpio_num_t&#160;</td>
          <td class="paramname"><em>VSyncGPIO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the 64 colors (8 GPIOs) initializer. </p>
<p>Two GPIOs per channel, plus horizontal and vertical sync signals.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">red1GPIO</td><td>GPIO to use for red channel, MSB bit. </td></tr>
    <tr><td class="paramname">red0GPIO</td><td>GPIO to use for red channel, LSB bit. </td></tr>
    <tr><td class="paramname">green1GPIO</td><td>GPIO to use for green channel, MSB bit. </td></tr>
    <tr><td class="paramname">green0GPIO</td><td>GPIO to use for green channel, LSB bit. </td></tr>
    <tr><td class="paramname">blue1GPIO</td><td>GPIO to use for blue channel, MSB bit. </td></tr>
    <tr><td class="paramname">blue0GPIO</td><td>GPIO to use for blue channel, LSB bit. </td></tr>
    <tr><td class="paramname">HSyncGPIO</td><td>GPIO to use for horizontal sync signal. </td></tr>
    <tr><td class="paramname">VSyncGPIO</td><td>GPIO to use for vertical sync signal.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><pre class="fragment">// Use GPIO 22-21 for red, GPIO 19-18 for green, GPIO 5-4 for blue, GPIO 23 for HSync and GPIO 15 for VSync
VGAController.begin(GPIO_NUM_22, GPIO_NUM_21, GPIO_NUM_19, GPIO_NUM_18, GPIO_NUM_5, GPIO_NUM_4, GPIO_NUM_23, GPIO_NUM_15);</pre> 
</div>
</div>
<a id="a58c07cf7f184101d20a642b8c7cb8eb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58c07cf7f184101d20a642b8c7cb8eb2">&#9670;&nbsp;</a></span>enableBackgroundPrimitiveExecution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FabGL::VGAControllerClass::enableBackgroundPrimitiveExecution </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable drawings inside vertical retracing time. </p>
<p>When vertical retracing occurs (on Vertical Sync) an interrupt is trigged. Inside this interrupt primitives like line, circles, glyphs, etc.. are painted. This method can disable (or reenable) this behavior, making drawing instantaneous. Flickering may occur when drawings are executed out of retracing time. When background executing is disabled the queue is emptied executing all pending primitives.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>When true drawings are done during vertical retracing, when false drawings are executed instantly. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91562139b5d73c2a7b7dcd43fd0a96d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91562139b5d73c2a7b7dcd43fd0a96d5">&#9670;&nbsp;</a></span>getBitsPerChannel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t FabGL::VGAControllerClass::getBitsPerChannel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get number of bits allocated for each channel. </p>
<p>Number of bits depends by which <a class="el" href="class_fab_g_l_1_1_v_g_a_controller_class.html#aade3e715b1c95b0b96d694fd55baece9" title="This is the 8 colors (5 GPIOs) initializer. ">begin()</a> initializer has been called.</p>
<dl class="section return"><dt>Returns</dt><dd>1 (8 colors) or 2 (64 colors). </dd></dl>

</div>
</div>
<a id="a459bde05feea992889fb874435b5baa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a459bde05feea992889fb874435b5baa7">&#9670;&nbsp;</a></span>getScreenHeight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FabGL::VGAControllerClass::getScreenHeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the screen height in pixels. </p>
<dl class="section return"><dt>Returns</dt><dd>Screen height in pixels. </dd></dl>

</div>
</div>
<a id="ae7eae8c450eccb9231bbb70e0bbf8831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7eae8c450eccb9231bbb70e0bbf8831">&#9670;&nbsp;</a></span>getScreenWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FabGL::VGAControllerClass::getScreenWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the screen width in pixels. </p>
<dl class="section return"><dt>Returns</dt><dd>Screen width in pixels. </dd></dl>

</div>
</div>
<a id="af52445643b3d2a4e1485c2fe2a5218f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af52445643b3d2a4e1485c2fe2a5218f4">&#9670;&nbsp;</a></span>getViewPortCol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FabGL::VGAControllerClass::getViewPortCol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return horizontal position of the viewport. </p>
<dl class="section return"><dt>Returns</dt><dd>Horizontal position of the viewport (in case viewport width is less than screen width). </dd></dl>

</div>
</div>
<a id="ab199d37c94991eb5b133c1b3ad45ec9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab199d37c94991eb5b133c1b3ad45ec9c">&#9670;&nbsp;</a></span>getViewPortHeight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FabGL::VGAControllerClass::getViewPortHeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return vertical size of the viewport. </p>
<dl class="section return"><dt>Returns</dt><dd>Vertical size of the viewport. </dd></dl>

</div>
</div>
<a id="ad1b2078e925299261ea9e7a3116352c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b2078e925299261ea9e7a3116352c5">&#9670;&nbsp;</a></span>getViewPortRow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FabGL::VGAControllerClass::getViewPortRow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return vertical position of the viewport. </p>
<dl class="section return"><dt>Returns</dt><dd>Vertical position of the viewport (in case viewport height is less than screen height). </dd></dl>

</div>
</div>
<a id="a66c11001fa49ef4f326f4ed400ed4895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66c11001fa49ef4f326f4ed400ed4895">&#9670;&nbsp;</a></span>getViewPortWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FabGL::VGAControllerClass::getViewPortWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return horizontal size of the viewport. </p>
<dl class="section return"><dt>Returns</dt><dd>Horizontal size of the viewport. </dd></dl>

</div>
</div>
<a id="a01955a85d46edd00b0503c7f2a0b8fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01955a85d46edd00b0503c7f2a0b8fb1">&#9670;&nbsp;</a></span>isDoubleBuffered()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FabGL::VGAControllerClass::isDoubleBuffered </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if <a class="el" href="class_fab_g_l_1_1_v_g_a_controller_class.html" title="Represents the VGA controller. ">VGAControllerClass</a> is on double buffered mode. </p>
<dl class="section return"><dt>Returns</dt><dd>True if <a class="el" href="class_fab_g_l_1_1_v_g_a_controller_class.html" title="Represents the VGA controller. ">VGAControllerClass</a> is on double buffered mode. </dd></dl>

</div>
</div>
<a id="ab9cf1e40864d5a4d5242e0e76c54b81a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9cf1e40864d5a4d5242e0e76c54b81a">&#9670;&nbsp;</a></span>moveScreen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FabGL::VGAControllerClass::moveScreen </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>offsetX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>offsetY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move screen by specified horizontal and vertical offset. </p>
<p>Screen moving is performed moving horizontal and vertical Front and Back porchs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offsetX</td><td>Horizontal offset in pixels. &lt; 0 goes left, &gt; 0 goes right. </td></tr>
    <tr><td class="paramname">offsetY</td><td>Vertical offset in pixels. &lt; 0 goes up, &gt; 0 goes down.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><pre class="fragment">// Move screen 4 pixels right, 1 pixel left
VGAController.moveScreen(4, -1);</pre> 
</div>
</div>
<a id="a7d19331fea4f141cab7b942b7d524fe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d19331fea4f141cab7b942b7d524fe4">&#9670;&nbsp;</a></span>processPrimitives()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IRAM_ATTR FabGL::VGAControllerClass::processPrimitives </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw immediately all primitives in the queue. </p>
<p>Draws all primitives before they are processed in the vertical sync interrupt. May generate flickering because don't care of vertical sync. </p>

</div>
</div>
<a id="a6cbf7054fcf1f829e8327d2c2fc18b03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cbf7054fcf1f829e8327d2c2fc18b03">&#9670;&nbsp;</a></span>refreshSprites()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FabGL::VGAControllerClass::refreshSprites </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force the sprites to be updated. </p>
<p>Screen is automatically updated whenever a primitive is painted (look at <a class="el" href="class_fab_g_l_1_1_canvas_class.html" title="A class with a set of drawing methods. ">CanvasClass</a>). When a sprite updates its image or its position (or any other property) it is required to force a refresh using this method. <a class="el" href="class_fab_g_l_1_1_v_g_a_controller_class.html#a6cbf7054fcf1f829e8327d2c2fc18b03" title="Force the sprites to be updated. ">VGAControllerClass.refreshSprites()</a> is required also using double buffered mode, to paint sprites. </p>

</div>
</div>
<a id="aa329b92c25878731b603c9ae4fd69b4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa329b92c25878731b603c9ae4fd69b4b">&#9670;&nbsp;</a></span>removeSprites()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FabGL::VGAControllerClass::removeSprites </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empty the list of active sprites. </p>
<p>Call this method when you don't need active sprites anymore. </p>

</div>
</div>
<a id="a6784d28b04bd726e1d3bd34153b93aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6784d28b04bd726e1d3bd34153b93aa9">&#9670;&nbsp;</a></span>resumeBackgroundPrimitiveExecution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FabGL::VGAControllerClass::resumeBackgroundPrimitiveExecution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resume drawings after <a class="el" href="class_fab_g_l_1_1_v_g_a_controller_class.html#af2488e30e07c7c6b90d7b0c92e53e913" title="Suspend drawings. ">suspendBackgroundPrimitiveExecution()</a>. </p>
<p>Resumes drawings enabling vertical sync interrupt. </p>

</div>
</div>
<a id="aa70582ae68f10c17fec24cda63f433ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa70582ae68f10c17fec24cda63f433ba">&#9670;&nbsp;</a></span>setResolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FabGL::VGAControllerClass::setResolution </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>modeline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>viewPortWidth</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>viewPortHeight</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doubleBuffered</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set current resolution using linux-like modeline. </p>
<p>Modeline must have following syntax (non case sensitive): </p><pre class="fragment">"label" clock_mhz hdisp hsyncstart hsyncend htotal vdisp vsyncstart vsyncend vtotal (+HSync | -HSync) (+VSync | -VSync) [DoubleScan] [FrontPorchBegins | SyncBegins | BackPorchBegins | VisibleBegins]
</pre><p>In <a class="el" href="_fab_g_l_conf_8h.html" title="This file contains FabGL library configuration settings, like number of supported colors...">FabGLConf.h</a> there are macros with some predefined modelines for common resolutions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modeline</td><td>Linux-like modeline as specified above. </td></tr>
    <tr><td class="paramname">viewPortWidth</td><td>Horizontal viewport size in pixels. If less than zero (-1) it is sized to modeline visible area width. </td></tr>
    <tr><td class="paramname">viewPortHeight</td><td>Vertical viewport size in pixels. If less then zero (-1) it is sized to maximum allocable. </td></tr>
    <tr><td class="paramname">doubleBuffered</td><td>if True allocates another viewport of the same size to use as back buffer. Make sure there is enough free memory.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><pre class="fragment">// Use predefined modeline for 640x480@60Hz
VGAController.setResolution(VGA_640x480_60Hz);

// The same of above using modeline string
VGAController.setResolution("\"640x480@60Hz\" 25.175 640 656 752 800 480 490 492 525 -HSync -VSync");

// Set 640x382@60Hz but limit the viewport to 640x350
VGAController.setResolution(VGA_640x382_60Hz, 640, 350);</pre> 
</div>
</div>
<a id="a4dc5057bd666f81c640d375caed99eda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dc5057bd666f81c640d375caed99eda">&#9670;&nbsp;</a></span>setSprites()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FabGL::VGAControllerClass::setSprites </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>sprites</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the list of active sprites. </p>
<p>A sprite is an image that keeps background unchanged. There is no limit to the number of active sprites, but flickering and slow refresh happens when a lot of sprites (or large sprites) are visible. To empty the list of active sprites call <a class="el" href="class_fab_g_l_1_1_v_g_a_controller_class.html#aa329b92c25878731b603c9ae4fd69b4b" title="Empty the list of active sprites. ">VGAControllerClass.removeSprites()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sprites</td><td>The list of sprites to make currently active. </td></tr>
    <tr><td class="paramname">count</td><td>Number of sprites in the list.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><pre class="fragment">// define a sprite with user data (velX and velY)
struct MySprite : Sprite {
  int  velX;
  int  velY;
};

static MySprite sprites[10];

VGAController.setSprites(sprites, 10);</pre> 
</div>
</div>
<a id="a75c1029eb0a46d49c80ce53abd4bbab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75c1029eb0a46d49c80ce53abd4bbab9">&#9670;&nbsp;</a></span>shrinkScreen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FabGL::VGAControllerClass::shrinkScreen </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shrinkX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shrinkY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduce or expands screen size by the specified horizontal and vertical offset. </p>
<p>Screen shrinking is performed changing horizontal and vertical Front and Back porchs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shrinkX</td><td>Horizontal offset in pixels. &gt; 0 shrinks, &lt; 0 expands. </td></tr>
    <tr><td class="paramname">shrinkY</td><td>Vertical offset in pixels. &gt; 0 shrinks, &lt; 0 expands.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><pre class="fragment">// Shrink screen by 8 pixels and move by 8 pixels to the left
VGAController.shrinkScreen(8, 0);
VGAController.moveScreen(8, 0);</pre> 
</div>
</div>
<a id="af2488e30e07c7c6b90d7b0c92e53e913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2488e30e07c7c6b90d7b0c92e53e913">&#9670;&nbsp;</a></span>suspendBackgroundPrimitiveExecution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FabGL::VGAControllerClass::suspendBackgroundPrimitiveExecution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suspend drawings. </p>
<p>Suspends drawings disabling vertical sync interrupt. After call to <a class="el" href="class_fab_g_l_1_1_v_g_a_controller_class.html#af2488e30e07c7c6b90d7b0c92e53e913" title="Suspend drawings. ">suspendBackgroundPrimitiveExecution()</a> adding new primitives may cause a deadlock. To avoid it a call to "processPrimitives()" should be performed very often. This method maintains a counter so can be nested. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="vgacontroller_8h_source.html">vgacontroller.h</a></li>
<li>vgacontroller.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
