<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FabGL: fabgl::VGAControllerClass Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FabGL
   </div>
   <div id="projectbrief">ESP32 VGA Controller and Graphics Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classfabgl_1_1_v_g_a_controller_class.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classfabgl_1_1_v_g_a_controller_class-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">fabgl::VGAControllerClass Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents the VGA controller.  
 <a href="classfabgl_1_1_v_g_a_controller_class.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="vgacontroller_8h_source.html">vgacontroller.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acdc8b95372c01a76deeb4abe360d0295"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfabgl_1_1_v_g_a_controller_class.html#acdc8b95372c01a76deeb4abe360d0295">begin</a> (gpio_num_t redGPIO, gpio_num_t greenGPIO, gpio_num_t blueGPIO, gpio_num_t HSyncGPIO, gpio_num_t VSyncGPIO)</td></tr>
<tr class="memdesc:acdc8b95372c01a76deeb4abe360d0295"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the 8 colors (5 GPIOs) initializer.  <a href="#acdc8b95372c01a76deeb4abe360d0295">More...</a><br /></td></tr>
<tr class="separator:acdc8b95372c01a76deeb4abe360d0295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62e5ccbc44d03e43205403123f2bdd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfabgl_1_1_v_g_a_controller_class.html#ab62e5ccbc44d03e43205403123f2bdd1">begin</a> (gpio_num_t red1GPIO, gpio_num_t red0GPIO, gpio_num_t green1GPIO, gpio_num_t green0GPIO, gpio_num_t blue1GPIO, gpio_num_t blue0GPIO, gpio_num_t HSyncGPIO, gpio_num_t VSyncGPIO)</td></tr>
<tr class="memdesc:ab62e5ccbc44d03e43205403123f2bdd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the 64 colors (8 GPIOs) initializer.  <a href="#ab62e5ccbc44d03e43205403123f2bdd1">More...</a><br /></td></tr>
<tr class="separator:ab62e5ccbc44d03e43205403123f2bdd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af762ae3115f998e6a9fdf12d246689bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfabgl_1_1_v_g_a_controller_class.html#af762ae3115f998e6a9fdf12d246689bf">begin</a> ()</td></tr>
<tr class="memdesc:af762ae3115f998e6a9fdf12d246689bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the 64 colors (8 GPIOs) initializer using default pinout.  <a href="#af762ae3115f998e6a9fdf12d246689bf">More...</a><br /></td></tr>
<tr class="separator:af762ae3115f998e6a9fdf12d246689bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6257b8aeb6048b3c9075530ea4362654"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfabgl_1_1_v_g_a_controller_class.html#a6257b8aeb6048b3c9075530ea4362654">createRawPixel</a> (<a class="el" href="structfabgl_1_1_r_g_b.html">RGB</a> rgb)</td></tr>
<tr class="memdesc:a6257b8aeb6048b3c9075530ea4362654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a raw pixel to use with <a class="el" href="classfabgl_1_1_v_g_a_controller_class.html#a42d16928e14c395e491431e4b297b2c4" title="Sets a raw pixel prepared using VGAControllerClass.createRawPixel. ">VGAControllerClass.setRawPixel</a>.  <a href="#a6257b8aeb6048b3c9075530ea4362654">More...</a><br /></td></tr>
<tr class="separator:a6257b8aeb6048b3c9075530ea4362654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0814c52bfc5eecd93fbb5ebce8d423"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfabgl_1_1_v_g_a_controller_class.html#a7e0814c52bfc5eecd93fbb5ebce8d423">enableBackgroundPrimitiveExecution</a> (bool value)</td></tr>
<tr class="memdesc:a7e0814c52bfc5eecd93fbb5ebce8d423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables drawings inside vertical retracing time.  <a href="#a7e0814c52bfc5eecd93fbb5ebce8d423">More...</a><br /></td></tr>
<tr class="separator:a7e0814c52bfc5eecd93fbb5ebce8d423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae667203ac63d3c59b975f5cc862a61b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfabgl_1_1_v_g_a_controller_class.html#ae667203ac63d3c59b975f5cc862a61b9">enableBackgroundPrimitiveTimeout</a> (bool value)</td></tr>
<tr class="memdesc:ae667203ac63d3c59b975f5cc862a61b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables execution time limitation inside vertical retracing interrupt.  <a href="#ae667203ac63d3c59b975f5cc862a61b9">More...</a><br /></td></tr>
<tr class="separator:ae667203ac63d3c59b975f5cc862a61b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643740e39822e9e74e80be55ab9d34c1"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfabgl_1_1_v_g_a_controller_class.html#a643740e39822e9e74e80be55ab9d34c1">getBitsPerChannel</a> ()</td></tr>
<tr class="memdesc:a643740e39822e9e74e80be55ab9d34c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets number of bits allocated for each channel.  <a href="#a643740e39822e9e74e80be55ab9d34c1">More...</a><br /></td></tr>
<tr class="separator:a643740e39822e9e74e80be55ab9d34c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e987421a0498f478076676edffd607"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfabgl_1_1_v_g_a_controller_class.html#a47e987421a0498f478076676edffd607">getScanline</a> (int y)</td></tr>
<tr class="memdesc:a47e987421a0498f478076676edffd607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a raw scanline pointer.  <a href="#a47e987421a0498f478076676edffd607">More...</a><br /></td></tr>
<tr class="separator:a47e987421a0498f478076676edffd607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3406190a30fc46070da0a7353da4082"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfabgl_1_1_v_g_a_controller_class.html#af3406190a30fc46070da0a7353da4082">getScreenHeight</a> ()</td></tr>
<tr class="memdesc:af3406190a30fc46070da0a7353da4082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the screen height in pixels.  <a href="#af3406190a30fc46070da0a7353da4082">More...</a><br /></td></tr>
<tr class="separator:af3406190a30fc46070da0a7353da4082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7310c48604f37aec2ea3274fefd405c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfabgl_1_1_v_g_a_controller_class.html#ad7310c48604f37aec2ea3274fefd405c">getScreenWidth</a> ()</td></tr>
<tr class="memdesc:ad7310c48604f37aec2ea3274fefd405c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the screen width in pixels.  <a href="#ad7310c48604f37aec2ea3274fefd405c">More...</a><br /></td></tr>
<tr class="separator:ad7310c48604f37aec2ea3274fefd405c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a725e8d47fe8e3cab8eafaa631b61fb69"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfabgl_1_1_v_g_a_controller_class.html#a725e8d47fe8e3cab8eafaa631b61fb69">getViewPortCol</a> ()</td></tr>
<tr class="memdesc:a725e8d47fe8e3cab8eafaa631b61fb69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines horizontal position of the viewport.  <a href="#a725e8d47fe8e3cab8eafaa631b61fb69">More...</a><br /></td></tr>
<tr class="separator:a725e8d47fe8e3cab8eafaa631b61fb69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa929ec6c723ffc3fea0d2996224f972d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfabgl_1_1_v_g_a_controller_class.html#aa929ec6c723ffc3fea0d2996224f972d">getViewPortHeight</a> ()</td></tr>
<tr class="memdesc:aa929ec6c723ffc3fea0d2996224f972d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines vertical size of the viewport.  <a href="#aa929ec6c723ffc3fea0d2996224f972d">More...</a><br /></td></tr>
<tr class="separator:aa929ec6c723ffc3fea0d2996224f972d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53fbba084a7f46d9356871ed1b16af83"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfabgl_1_1_v_g_a_controller_class.html#a53fbba084a7f46d9356871ed1b16af83">getViewPortRow</a> ()</td></tr>
<tr class="memdesc:a53fbba084a7f46d9356871ed1b16af83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines vertical position of the viewport.  <a href="#a53fbba084a7f46d9356871ed1b16af83">More...</a><br /></td></tr>
<tr class="separator:a53fbba084a7f46d9356871ed1b16af83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537026eab81ff0f128185b0049644be5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfabgl_1_1_v_g_a_controller_class.html#a537026eab81ff0f128185b0049644be5">getViewPortWidth</a> ()</td></tr>
<tr class="memdesc:a537026eab81ff0f128185b0049644be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines horizontal size of the viewport.  <a href="#a537026eab81ff0f128185b0049644be5">More...</a><br /></td></tr>
<tr class="separator:a537026eab81ff0f128185b0049644be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac769ed638e5add668706de38f5d6c55a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfabgl_1_1_v_g_a_controller_class.html#ac769ed638e5add668706de38f5d6c55a">isDoubleBuffered</a> ()</td></tr>
<tr class="memdesc:ac769ed638e5add668706de38f5d6c55a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether <a class="el" href="classfabgl_1_1_v_g_a_controller_class.html" title="Represents the VGA controller. ">VGAControllerClass</a> is on double buffered mode.  <a href="#ac769ed638e5add668706de38f5d6c55a">More...</a><br /></td></tr>
<tr class="separator:ac769ed638e5add668706de38f5d6c55a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16843256aeff799ff96654cef6a231e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfabgl_1_1_v_g_a_controller_class.html#a16843256aeff799ff96654cef6a231e7">moveScreen</a> (int offsetX, int offsetY)</td></tr>
<tr class="memdesc:a16843256aeff799ff96654cef6a231e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves screen by specified horizontal and vertical offset.  <a href="#a16843256aeff799ff96654cef6a231e7">More...</a><br /></td></tr>
<tr class="separator:a16843256aeff799ff96654cef6a231e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f1f95c5ba5cfa97fdba9d7115f2286"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfabgl_1_1_v_g_a_controller_class.html#a25f1f95c5ba5cfa97fdba9d7115f2286">processPrimitives</a> ()</td></tr>
<tr class="memdesc:a25f1f95c5ba5cfa97fdba9d7115f2286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws immediately all primitives in the queue.  <a href="#a25f1f95c5ba5cfa97fdba9d7115f2286">More...</a><br /></td></tr>
<tr class="separator:a25f1f95c5ba5cfa97fdba9d7115f2286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcbaf2c8b9afb44376da7096c1e4438e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfabgl_1_1_v_g_a_controller_class.html#abcbaf2c8b9afb44376da7096c1e4438e">readScreen</a> (<a class="el" href="structfabgl_1_1_rect.html">Rect</a> const &amp;rect, <a class="el" href="structfabgl_1_1_r_g_b.html">RGB</a> *destBuf)</td></tr>
<tr class="memdesc:abcbaf2c8b9afb44376da7096c1e4438e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads pixels inside the specified rectangle.  <a href="#abcbaf2c8b9afb44376da7096c1e4438e">More...</a><br /></td></tr>
<tr class="separator:abcbaf2c8b9afb44376da7096c1e4438e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad964ad05d839dd99bd73897b5cab84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfabgl_1_1_v_g_a_controller_class.html#a9ad964ad05d839dd99bd73897b5cab84">refreshSprites</a> ()</td></tr>
<tr class="memdesc:a9ad964ad05d839dd99bd73897b5cab84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the sprites to be updated.  <a href="#a9ad964ad05d839dd99bd73897b5cab84">More...</a><br /></td></tr>
<tr class="separator:a9ad964ad05d839dd99bd73897b5cab84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574b90ddf0e243837ea00ff0c3ebc8d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfabgl_1_1_v_g_a_controller_class.html#a574b90ddf0e243837ea00ff0c3ebc8d6">removeSprites</a> ()</td></tr>
<tr class="memdesc:a574b90ddf0e243837ea00ff0c3ebc8d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empties the list of active sprites.  <a href="#a574b90ddf0e243837ea00ff0c3ebc8d6">More...</a><br /></td></tr>
<tr class="separator:a574b90ddf0e243837ea00ff0c3ebc8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa57c12d24f1706685afa7d7e96c2cdc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfabgl_1_1_v_g_a_controller_class.html#afa57c12d24f1706685afa7d7e96c2cdc">resumeBackgroundPrimitiveExecution</a> ()</td></tr>
<tr class="memdesc:afa57c12d24f1706685afa7d7e96c2cdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resumes drawings after <a class="el" href="classfabgl_1_1_v_g_a_controller_class.html#acc8e8edb6d677fed102ca33cb59badf2" title="Suspends drawings. ">suspendBackgroundPrimitiveExecution()</a>.  <a href="#afa57c12d24f1706685afa7d7e96c2cdc">More...</a><br /></td></tr>
<tr class="separator:afa57c12d24f1706685afa7d7e96c2cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a192b049b972edc3eb8a817d641688f7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfabgl_1_1_v_g_a_controller_class.html#a192b049b972edc3eb8a817d641688f7d">setMouseCursor</a> (<a class="el" href="structfabgl_1_1_cursor.html">Cursor</a> const *cursor)</td></tr>
<tr class="memdesc:a192b049b972edc3eb8a817d641688f7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets mouse cursor and make it visible.  <a href="#a192b049b972edc3eb8a817d641688f7d">More...</a><br /></td></tr>
<tr class="separator:a192b049b972edc3eb8a817d641688f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b4775f4fc880932ae1abeeb0a1acc0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfabgl_1_1_v_g_a_controller_class.html#ae4b4775f4fc880932ae1abeeb0a1acc0">setMouseCursor</a> (<a class="el" href="group___enumerations.html#gae9affb623792aa869a11e81f3f10a372">CursorName</a> cursorName)</td></tr>
<tr class="memdesc:ae4b4775f4fc880932ae1abeeb0a1acc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets mouse cursor from a set of predefined cursors.  <a href="#ae4b4775f4fc880932ae1abeeb0a1acc0">More...</a><br /></td></tr>
<tr class="separator:ae4b4775f4fc880932ae1abeeb0a1acc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5351ed408f04a666b3969311f59956cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfabgl_1_1_v_g_a_controller_class.html#a5351ed408f04a666b3969311f59956cb">setMouseCursorPos</a> (int X, int Y)</td></tr>
<tr class="memdesc:a5351ed408f04a666b3969311f59956cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets mouse cursor position.  <a href="#a5351ed408f04a666b3969311f59956cb">More...</a><br /></td></tr>
<tr class="separator:a5351ed408f04a666b3969311f59956cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d16928e14c395e491431e4b297b2c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfabgl_1_1_v_g_a_controller_class.html#a42d16928e14c395e491431e4b297b2c4">setRawPixel</a> (int x, int y, uint8_t rgb)</td></tr>
<tr class="memdesc:a42d16928e14c395e491431e4b297b2c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a raw pixel prepared using <a class="el" href="classfabgl_1_1_v_g_a_controller_class.html#a6257b8aeb6048b3c9075530ea4362654" title="Creates a raw pixel to use with VGAControllerClass.setRawPixel. ">VGAControllerClass.createRawPixel</a>.  <a href="#a42d16928e14c395e491431e4b297b2c4">More...</a><br /></td></tr>
<tr class="separator:a42d16928e14c395e491431e4b297b2c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac190a844ead4bb68817c733fb0c9a5af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfabgl_1_1_v_g_a_controller_class.html#ac190a844ead4bb68817c733fb0c9a5af">setResolution</a> (char const *modeline, int viewPortWidth=-1, int viewPortHeight=-1, bool doubleBuffered=false)</td></tr>
<tr class="memdesc:ac190a844ead4bb68817c733fb0c9a5af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets current resolution using linux-like modeline.  <a href="#ac190a844ead4bb68817c733fb0c9a5af">More...</a><br /></td></tr>
<tr class="separator:ac190a844ead4bb68817c733fb0c9a5af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba7a412c75f41a898929e18dae10353"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7ba7a412c75f41a898929e18dae10353"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfabgl_1_1_v_g_a_controller_class.html#a7ba7a412c75f41a898929e18dae10353">setSprites</a> (T *sprites, int count)</td></tr>
<tr class="memdesc:a7ba7a412c75f41a898929e18dae10353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the list of active sprites.  <a href="#a7ba7a412c75f41a898929e18dae10353">More...</a><br /></td></tr>
<tr class="separator:a7ba7a412c75f41a898929e18dae10353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb399316e3a45b6b3ae601544dbc3a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfabgl_1_1_v_g_a_controller_class.html#affb399316e3a45b6b3ae601544dbc3a9">shrinkScreen</a> (int shrinkX, int shrinkY)</td></tr>
<tr class="memdesc:affb399316e3a45b6b3ae601544dbc3a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces or expands screen size by the specified horizontal and vertical offset.  <a href="#affb399316e3a45b6b3ae601544dbc3a9">More...</a><br /></td></tr>
<tr class="separator:affb399316e3a45b6b3ae601544dbc3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc8e8edb6d677fed102ca33cb59badf2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfabgl_1_1_v_g_a_controller_class.html#acc8e8edb6d677fed102ca33cb59badf2">suspendBackgroundPrimitiveExecution</a> ()</td></tr>
<tr class="memdesc:acc8e8edb6d677fed102ca33cb59badf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspends drawings.  <a href="#acc8e8edb6d677fed102ca33cb59badf2">More...</a><br /></td></tr>
<tr class="separator:acc8e8edb6d677fed102ca33cb59badf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7c2b7881a541405690fe44f4c94be6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfabgl_1_1_v_g_a_controller_class.html#aeb7c2b7881a541405690fe44f4c94be6">writeScreen</a> (<a class="el" href="structfabgl_1_1_rect.html">Rect</a> const &amp;rect, <a class="el" href="structfabgl_1_1_r_g_b.html">RGB</a> *srcBuf)</td></tr>
<tr class="memdesc:aeb7c2b7881a541405690fe44f4c94be6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes pixels inside the specified rectangle.  <a href="#aeb7c2b7881a541405690fe44f4c94be6">More...</a><br /></td></tr>
<tr class="separator:aeb7c2b7881a541405690fe44f4c94be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents the VGA controller. </p>
<p>Use this class to set screen resolution and to associate VGA signals to ESP32 GPIO outputs.</p>
<p>This example initializes VGA Controller with 8 colors (5 GPIOs used) and 640x350 resolution: </p><pre class="fragment">// Assign GPIO22 to Red, GPIO21 to Green, GPIO19 to Blue, GPIO18 to HSync and GPIO5 to VSync
VGAController.begin(GPIO_NUM_22, GPIO_NUM_21, GPIO_NUM_19, GPIO_NUM_18, GPIO_NUM_5);

// Set 640x350@70Hz resolution
VGAController.setResolution(VGA_640x350_70Hz);
</pre><p>This example initializes VGA Controller with 64 colors (8 GPIOs used) and 640x350 resolution: </p><pre class="fragment">// Assign GPIO22 and GPIO_NUM_21 to Red, GPIO_NUM_19 and GPIO_NUM_18 to Green, GPIO_NUM_5 and GPIO_NUM_4 to Blue, GPIO_NUM_23 to HSync and GPIO_NUM_15 to VSync
VGAController.begin(GPIO_NUM_22, GPIO_NUM_21, GPIO_NUM_19, GPIO_NUM_18, GPIO_NUM_5, GPIO_NUM_4, GPIO_NUM_23, GPIO_NUM_15);

// Set 640x350@70Hz resolution
VGAController.setResolution(VGA_640x350_70Hz);</pre> </div><h2 class="groupheader">Member Function Documentation</h2>
<a id="acdc8b95372c01a76deeb4abe360d0295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc8b95372c01a76deeb4abe360d0295">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fabgl::VGAControllerClass::begin </td>
          <td>(</td>
          <td class="paramtype">gpio_num_t&#160;</td>
          <td class="paramname"><em>redGPIO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gpio_num_t&#160;</td>
          <td class="paramname"><em>greenGPIO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gpio_num_t&#160;</td>
          <td class="paramname"><em>blueGPIO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gpio_num_t&#160;</td>
          <td class="paramname"><em>HSyncGPIO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gpio_num_t&#160;</td>
          <td class="paramname"><em>VSyncGPIO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the 8 colors (5 GPIOs) initializer. </p>
<p>One GPIO per channel, plus horizontal and vertical sync signals.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">redGPIO</td><td>GPIO to use for red channel. </td></tr>
    <tr><td class="paramname">greenGPIO</td><td>GPIO to use for green channel. </td></tr>
    <tr><td class="paramname">blueGPIO</td><td>GPIO to use for blue channel. </td></tr>
    <tr><td class="paramname">HSyncGPIO</td><td>GPIO to use for horizontal sync signal. </td></tr>
    <tr><td class="paramname">VSyncGPIO</td><td>GPIO to use for vertical sync signal.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><pre class="fragment">// Use GPIO 22 for red, GPIO 21 for green, GPIO 19 for blue, GPIO 18 for HSync and GPIO 5 for VSync
VGAController.begin(GPIO_NUM_22, GPIO_NUM_21, GPIO_NUM_19, GPIO_NUM_18, GPIO_NUM_5);</pre> <dl><dt><b>Examples: </b></dt><dd><a class="el" href="_altair8800_2_altair8800_8ino-example.html#a8">Altair8800/Altair8800.ino</a>, <a class="el" href="_ansi_terminal_2_ansi_terminal_8ino-example.html#a1">AnsiTerminal/AnsiTerminal.ino</a>, <a class="el" href="_audio_2_audio_8ino-example.html#a1">Audio/Audio.ino</a>, <a class="el" href="_collision_detection_2_collision_detection_8ino-example.html#a9">CollisionDetection/CollisionDetection.ino</a>, <a class="el" href="_double_buffer_2_double_buffer_8ino-example.html#a0">DoubleBuffer/DoubleBuffer.ino</a>, <a class="el" href="_graphical_user_interface_2_graphical_user_interface_8ino-example.html#a1">GraphicalUserInterface/GraphicalUserInterface.ino</a>, <a class="el" href="_loopback_terminal_2_loopback_terminal_8ino-example.html#a4">LoopbackTerminal/LoopbackTerminal.ino</a>, <a class="el" href="_modeline_studio_2_modeline_studio_8ino-example.html#a52">ModelineStudio/ModelineStudio.ino</a>, <a class="el" href="_mouse_on_screen_2_mouse_on_screen_8ino-example.html#a5">MouseOnScreen/MouseOnScreen.ino</a>, <a class="el" href="_network_terminal_2_network_terminal_8ino-example.html#a4">NetworkTerminal/NetworkTerminal.ino</a>, <a class="el" href="_simple_terminal_out_2_simple_terminal_out_8ino-example.html#a0">SimpleTerminalOut/SimpleTerminalOut.ino</a>, <a class="el" href="_space_invaders_2_space_invaders_8ino-example.html#a38">SpaceInvaders/SpaceInvaders.ino</a>, and <a class="el" href="_v_i_c20_2_v_i_c20_8ino-example.html#a16">VIC20/VIC20.ino</a>.</dd>
</dl>
</div>
</div>
<a id="ab62e5ccbc44d03e43205403123f2bdd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab62e5ccbc44d03e43205403123f2bdd1">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fabgl::VGAControllerClass::begin </td>
          <td>(</td>
          <td class="paramtype">gpio_num_t&#160;</td>
          <td class="paramname"><em>red1GPIO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gpio_num_t&#160;</td>
          <td class="paramname"><em>red0GPIO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gpio_num_t&#160;</td>
          <td class="paramname"><em>green1GPIO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gpio_num_t&#160;</td>
          <td class="paramname"><em>green0GPIO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gpio_num_t&#160;</td>
          <td class="paramname"><em>blue1GPIO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gpio_num_t&#160;</td>
          <td class="paramname"><em>blue0GPIO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gpio_num_t&#160;</td>
          <td class="paramname"><em>HSyncGPIO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gpio_num_t&#160;</td>
          <td class="paramname"><em>VSyncGPIO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the 64 colors (8 GPIOs) initializer. </p>
<p>Two GPIOs per channel, plus horizontal and vertical sync signals.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">red1GPIO</td><td>GPIO to use for red channel, MSB bit. </td></tr>
    <tr><td class="paramname">red0GPIO</td><td>GPIO to use for red channel, LSB bit. </td></tr>
    <tr><td class="paramname">green1GPIO</td><td>GPIO to use for green channel, MSB bit. </td></tr>
    <tr><td class="paramname">green0GPIO</td><td>GPIO to use for green channel, LSB bit. </td></tr>
    <tr><td class="paramname">blue1GPIO</td><td>GPIO to use for blue channel, MSB bit. </td></tr>
    <tr><td class="paramname">blue0GPIO</td><td>GPIO to use for blue channel, LSB bit. </td></tr>
    <tr><td class="paramname">HSyncGPIO</td><td>GPIO to use for horizontal sync signal. </td></tr>
    <tr><td class="paramname">VSyncGPIO</td><td>GPIO to use for vertical sync signal.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><pre class="fragment">// Use GPIO 22-21 for red, GPIO 19-18 for green, GPIO 5-4 for blue, GPIO 23 for HSync and GPIO 15 for VSync
VGAController.begin(GPIO_NUM_22, GPIO_NUM_21, GPIO_NUM_19, GPIO_NUM_18, GPIO_NUM_5, GPIO_NUM_4, GPIO_NUM_23, GPIO_NUM_15);</pre> 
</div>
</div>
<a id="af762ae3115f998e6a9fdf12d246689bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af762ae3115f998e6a9fdf12d246689bf">&#9670;&nbsp;</a></span>begin() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fabgl::VGAControllerClass::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the 64 colors (8 GPIOs) initializer using default pinout. </p>
<p>Two GPIOs per channel, plus horizontal and vertical sync signals. Use GPIO 22-21 for red, GPIO 19-18 for green, GPIO 5-4 for blue, GPIO 23 for HSync and GPIO 15 for VSync</p>
<p>Example: </p><pre class="fragment">VGAController.begin();</pre> 
</div>
</div>
<a id="a6257b8aeb6048b3c9075530ea4362654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6257b8aeb6048b3c9075530ea4362654">&#9670;&nbsp;</a></span>createRawPixel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t fabgl::VGAControllerClass::createRawPixel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfabgl_1_1_r_g_b.html">RGB</a>&#160;</td>
          <td class="paramname"><em>rgb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a raw pixel to use with <a class="el" href="classfabgl_1_1_v_g_a_controller_class.html#a42d16928e14c395e491431e4b297b2c4" title="Sets a raw pixel prepared using VGAControllerClass.createRawPixel. ">VGAControllerClass.setRawPixel</a>. </p>
<p>A raw pixel (or raw color) is a byte (uint8_t) that contains color information and synchronization signals.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rgb</td><td>Pixel <a class="el" href="structfabgl_1_1_r_g_b.html" title="Represents an RGB color. ">RGB</a> color</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><pre class="fragment">// Set color of pixel at 100, 100
VGAController.setRawPixel(100, 100, VGAController.createRawPixel(RGB(3, 0, 0));</pre> 
</div>
</div>
<a id="a7e0814c52bfc5eecd93fbb5ebce8d423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e0814c52bfc5eecd93fbb5ebce8d423">&#9670;&nbsp;</a></span>enableBackgroundPrimitiveExecution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fabgl::VGAControllerClass::enableBackgroundPrimitiveExecution </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables or disables drawings inside vertical retracing time. </p>
<p>When vertical retracing occurs (on Vertical Sync) an interrupt is trigged. Inside this interrupt primitives like line, circles, glyphs, etc.. are painted.<br />
 This method can disable (or reenable) this behavior, making drawing instantaneous. Flickering may occur when drawings are executed out of retracing time.<br />
 When background executing is disabled the queue is emptied executing all pending primitives.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>When true drawings are done during vertical retracing, when false drawings are executed instantly. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="_altair8800_2_altair8800_8ino-example.html#a12">Altair8800/Altair8800.ino</a>, <a class="el" href="_ansi_terminal_2_ansi_terminal_8ino-example.html#a4">AnsiTerminal/AnsiTerminal.ino</a>, <a class="el" href="_network_terminal_2_network_terminal_8ino-example.html#a7">NetworkTerminal/NetworkTerminal.ino</a>, and <a class="el" href="_simple_terminal_out_2_simple_terminal_out_8ino-example.html#a3">SimpleTerminalOut/SimpleTerminalOut.ino</a>.</dd>
</dl>
</div>
</div>
<a id="ae667203ac63d3c59b975f5cc862a61b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae667203ac63d3c59b975f5cc862a61b9">&#9670;&nbsp;</a></span>enableBackgroundPrimitiveTimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fabgl::VGAControllerClass::enableBackgroundPrimitiveTimeout </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables or disables execution time limitation inside vertical retracing interrupt. </p>
<p>Disabling interrupt execution timeout may generate flickering but speedup drawing operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>True enables timeout (default), False disables timeout </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="_v_i_c20_2_v_i_c20_8ino-example.html#a19">VIC20/VIC20.ino</a>.</dd>
</dl>
</div>
</div>
<a id="a643740e39822e9e74e80be55ab9d34c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a643740e39822e9e74e80be55ab9d34c1">&#9670;&nbsp;</a></span>getBitsPerChannel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t fabgl::VGAControllerClass::getBitsPerChannel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets number of bits allocated for each channel. </p>
<p>Number of bits depends by which <a class="el" href="classfabgl_1_1_v_g_a_controller_class.html#af762ae3115f998e6a9fdf12d246689bf" title="This is the 64 colors (8 GPIOs) initializer using default pinout. ">begin()</a> initializer has been called.</p>
<dl class="section return"><dt>Returns</dt><dd>1 (8 colors) or 2 (64 colors). </dd></dl>

</div>
</div>
<a id="a47e987421a0498f478076676edffd607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47e987421a0498f478076676edffd607">&#9670;&nbsp;</a></span>getScanline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* fabgl::VGAControllerClass::getScanline </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a raw scanline pointer. </p>
<p>A raw scanline must be filled with raw pixel colors. Use <a class="el" href="classfabgl_1_1_v_g_a_controller_class.html#a6257b8aeb6048b3c9075530ea4362654" title="Creates a raw pixel to use with VGAControllerClass.setRawPixel. ">VGAControllerClass.createRawPixel</a> to create raw pixel colors. A raw pixel (or raw color) is a byte (uint8_t) that contains color information and synchronization signals. Pixels are arranged in 32 bit packes as follows: pixel 0 = byte 2, pixel 1 = byte 3, pixel 2 = byte 0, pixel 3 = byte 1 : pixel : 0 1 2 3 4 5 6 7 8 9 10 11 ...etc... byte : 2 3 0 1 6 7 4 5 10 11 8 9 ...etc... dword : 0 1 2 ...etc...</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Vertical scanline position (0 = top row) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3406190a30fc46070da0a7353da4082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3406190a30fc46070da0a7353da4082">&#9670;&nbsp;</a></span>getScreenHeight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int fabgl::VGAControllerClass::getScreenHeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the screen height in pixels. </p>
<dl class="section return"><dt>Returns</dt><dd>Screen height in pixels. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="_ansi_terminal_2_ansi_terminal_8ino-example.html#a8">AnsiTerminal/AnsiTerminal.ino</a>, <a class="el" href="_loopback_terminal_2_loopback_terminal_8ino-example.html#a1">LoopbackTerminal/LoopbackTerminal.ino</a>, <a class="el" href="_modeline_studio_2_modeline_studio_8ino-example.html#a33">ModelineStudio/ModelineStudio.ino</a>, <a class="el" href="_network_terminal_2_network_terminal_8ino-example.html#a1">NetworkTerminal/NetworkTerminal.ino</a>, and <a class="el" href="_simple_terminal_out_2_simple_terminal_out_8ino-example.html#a5">SimpleTerminalOut/SimpleTerminalOut.ino</a>.</dd>
</dl>
</div>
</div>
<a id="ad7310c48604f37aec2ea3274fefd405c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7310c48604f37aec2ea3274fefd405c">&#9670;&nbsp;</a></span>getScreenWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int fabgl::VGAControllerClass::getScreenWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the screen width in pixels. </p>
<dl class="section return"><dt>Returns</dt><dd>Screen width in pixels. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="_ansi_terminal_2_ansi_terminal_8ino-example.html#a7">AnsiTerminal/AnsiTerminal.ino</a>, <a class="el" href="_loopback_terminal_2_loopback_terminal_8ino-example.html#a0">LoopbackTerminal/LoopbackTerminal.ino</a>, <a class="el" href="_modeline_studio_2_modeline_studio_8ino-example.html#a32">ModelineStudio/ModelineStudio.ino</a>, <a class="el" href="_network_terminal_2_network_terminal_8ino-example.html#a0">NetworkTerminal/NetworkTerminal.ino</a>, and <a class="el" href="_simple_terminal_out_2_simple_terminal_out_8ino-example.html#a4">SimpleTerminalOut/SimpleTerminalOut.ino</a>.</dd>
</dl>
</div>
</div>
<a id="a725e8d47fe8e3cab8eafaa631b61fb69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a725e8d47fe8e3cab8eafaa631b61fb69">&#9670;&nbsp;</a></span>getViewPortCol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int fabgl::VGAControllerClass::getViewPortCol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines horizontal position of the viewport. </p>
<dl class="section return"><dt>Returns</dt><dd>Horizontal position of the viewport (in case viewport width is less than screen width). </dd></dl>

</div>
</div>
<a id="aa929ec6c723ffc3fea0d2996224f972d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa929ec6c723ffc3fea0d2996224f972d">&#9670;&nbsp;</a></span>getViewPortHeight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int fabgl::VGAControllerClass::getViewPortHeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines vertical size of the viewport. </p>
<dl class="section return"><dt>Returns</dt><dd>Vertical size of the viewport. </dd></dl>

</div>
</div>
<a id="a53fbba084a7f46d9356871ed1b16af83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53fbba084a7f46d9356871ed1b16af83">&#9670;&nbsp;</a></span>getViewPortRow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int fabgl::VGAControllerClass::getViewPortRow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines vertical position of the viewport. </p>
<dl class="section return"><dt>Returns</dt><dd>Vertical position of the viewport (in case viewport height is less than screen height). </dd></dl>

</div>
</div>
<a id="a537026eab81ff0f128185b0049644be5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a537026eab81ff0f128185b0049644be5">&#9670;&nbsp;</a></span>getViewPortWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int fabgl::VGAControllerClass::getViewPortWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines horizontal size of the viewport. </p>
<dl class="section return"><dt>Returns</dt><dd>Horizontal size of the viewport. </dd></dl>

</div>
</div>
<a id="ac769ed638e5add668706de38f5d6c55a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac769ed638e5add668706de38f5d6c55a">&#9670;&nbsp;</a></span>isDoubleBuffered()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fabgl::VGAControllerClass::isDoubleBuffered </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether <a class="el" href="classfabgl_1_1_v_g_a_controller_class.html" title="Represents the VGA controller. ">VGAControllerClass</a> is on double buffered mode. </p>
<dl class="section return"><dt>Returns</dt><dd>True if <a class="el" href="classfabgl_1_1_v_g_a_controller_class.html" title="Represents the VGA controller. ">VGAControllerClass</a> is on double buffered mode. </dd></dl>

</div>
</div>
<a id="a16843256aeff799ff96654cef6a231e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16843256aeff799ff96654cef6a231e7">&#9670;&nbsp;</a></span>moveScreen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fabgl::VGAControllerClass::moveScreen </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offsetX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offsetY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves screen by specified horizontal and vertical offset. </p>
<p>Screen moving is performed moving horizontal and vertical Front and Back porchs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offsetX</td><td>Horizontal offset in pixels. &lt; 0 goes left, &gt; 0 goes right. </td></tr>
    <tr><td class="paramname">offsetY</td><td>Vertical offset in pixels. &lt; 0 goes up, &gt; 0 goes down.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><pre class="fragment">// Move screen 4 pixels right, 1 pixel left
VGAController.moveScreen(4, -1);</pre> <dl><dt><b>Examples: </b></dt><dd><a class="el" href="_audio_2_audio_8ino-example.html#a4">Audio/Audio.ino</a>, <a class="el" href="_collision_detection_2_collision_detection_8ino-example.html#a12">CollisionDetection/CollisionDetection.ino</a>, <a class="el" href="_modeline_studio_2_modeline_studio_8ino-example.html#a55">ModelineStudio/ModelineStudio.ino</a>, and <a class="el" href="_space_invaders_2_space_invaders_8ino-example.html#a41">SpaceInvaders/SpaceInvaders.ino</a>.</dd>
</dl>
</div>
</div>
<a id="a25f1f95c5ba5cfa97fdba9d7115f2286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25f1f95c5ba5cfa97fdba9d7115f2286">&#9670;&nbsp;</a></span>processPrimitives()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IRAM_ATTR fabgl::VGAControllerClass::processPrimitives </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draws immediately all primitives in the queue. </p>
<p>Draws all primitives before they are processed in the vertical sync interrupt.<br />
 May generate flickering because don't care of vertical sync. </p>

</div>
</div>
<a id="abcbaf2c8b9afb44376da7096c1e4438e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcbaf2c8b9afb44376da7096c1e4438e">&#9670;&nbsp;</a></span>readScreen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fabgl::VGAControllerClass::readScreen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfabgl_1_1_rect.html">Rect</a> const &amp;&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfabgl_1_1_r_g_b.html">RGB</a> *&#160;</td>
          <td class="paramname"><em>destBuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads pixels inside the specified rectangle. </p>
<p>Screen reading may occur while other drawings are in progress, so the result may be not updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>Screen rectangle to read. To improve performance rectangle is not checked. </td></tr>
    <tr><td class="paramname">destBuf</td><td>Destination buffer. Buffer size must be at least rect.width() * rect.height.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><pre class="fragment">// paint a red rectangle
Canvas.setBrushColor(RGB(3, 0, 0));
Rect rect = Rect(10, 10, 100, 100);
Canvas.fillRectangle(rect);

// wait for vsync (hence actual drawing)
VGAController.processPrimitives();

// read rectangle pixels into "buf"
auto buf = new RGB[rect.width() * rect.height()];
VGAController.readScreen(rect, buf);

// write buf 110 pixels to the reight
VGAController.writeScreen(rect.translate(110, 0), buf);
delete buf;</pre> 
</div>
</div>
<a id="a9ad964ad05d839dd99bd73897b5cab84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ad964ad05d839dd99bd73897b5cab84">&#9670;&nbsp;</a></span>refreshSprites()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fabgl::VGAControllerClass::refreshSprites </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forces the sprites to be updated. </p>
<p>Screen is automatically updated whenever a primitive is painted (look at <a class="el" href="classfabgl_1_1_canvas_class.html" title="A class with a set of drawing methods. ">CanvasClass</a>).<br />
 When a sprite updates its image or its position (or any other property) it is required to force a refresh using this method.<br />
 <a class="el" href="classfabgl_1_1_v_g_a_controller_class.html#a9ad964ad05d839dd99bd73897b5cab84" title="Forces the sprites to be updated. ">VGAControllerClass.refreshSprites()</a> is required also when using the double buffered mode, to paint sprites. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="_collision_detection_2_collision_detection_8ino-example.html#a1">CollisionDetection/CollisionDetection.ino</a>, and <a class="el" href="_space_invaders_2_space_invaders_8ino-example.html#a36">SpaceInvaders/SpaceInvaders.ino</a>.</dd>
</dl>
</div>
</div>
<a id="a574b90ddf0e243837ea00ff0c3ebc8d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a574b90ddf0e243837ea00ff0c3ebc8d6">&#9670;&nbsp;</a></span>removeSprites()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fabgl::VGAControllerClass::removeSprites </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empties the list of active sprites. </p>
<p>Call this method when you don't need active sprites anymore. </p>

</div>
</div>
<a id="afa57c12d24f1706685afa7d7e96c2cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa57c12d24f1706685afa7d7e96c2cdc">&#9670;&nbsp;</a></span>resumeBackgroundPrimitiveExecution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fabgl::VGAControllerClass::resumeBackgroundPrimitiveExecution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resumes drawings after <a class="el" href="classfabgl_1_1_v_g_a_controller_class.html#acc8e8edb6d677fed102ca33cb59badf2" title="Suspends drawings. ">suspendBackgroundPrimitiveExecution()</a>. </p>
<p>Resumes drawings enabling vertical sync interrupt. </p>

</div>
</div>
<a id="a192b049b972edc3eb8a817d641688f7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a192b049b972edc3eb8a817d641688f7d">&#9670;&nbsp;</a></span>setMouseCursor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fabgl::VGAControllerClass::setMouseCursor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfabgl_1_1_cursor.html">Cursor</a> const *&#160;</td>
          <td class="paramname"><em>cursor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets mouse cursor and make it visible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td><a class="el" href="structfabgl_1_1_cursor.html" title="Defines a cursor. ">Cursor</a> to use when mouse pointer need to be painted. nullptr = disable mouse pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="_mouse_on_screen_2_mouse_on_screen_8ino-example.html#a12">MouseOnScreen/MouseOnScreen.ino</a>.</dd>
</dl>
</div>
</div>
<a id="ae4b4775f4fc880932ae1abeeb0a1acc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4b4775f4fc880932ae1abeeb0a1acc0">&#9670;&nbsp;</a></span>setMouseCursor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fabgl::VGAControllerClass::setMouseCursor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___enumerations.html#gae9affb623792aa869a11e81f3f10a372">CursorName</a>&#160;</td>
          <td class="paramname"><em>cursorName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets mouse cursor from a set of predefined cursors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursorName</td><td>Name (enum) of predefined cursor.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><pre class="fragment">VGAController.setMouseCursor(CursorName::CursorPointerShadowed);</pre> 
</div>
</div>
<a id="a5351ed408f04a666b3969311f59956cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5351ed408f04a666b3969311f59956cb">&#9670;&nbsp;</a></span>setMouseCursorPos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fabgl::VGAControllerClass::setMouseCursorPos </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets mouse cursor position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>Mouse cursor horizontal position. </td></tr>
    <tr><td class="paramname">Y</td><td>Mouse cursor vertical position. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42d16928e14c395e491431e4b297b2c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42d16928e14c395e491431e4b297b2c4">&#9670;&nbsp;</a></span>setRawPixel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fabgl::VGAControllerClass::setRawPixel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rgb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a raw pixel prepared using <a class="el" href="classfabgl_1_1_v_g_a_controller_class.html#a6257b8aeb6048b3c9075530ea4362654" title="Creates a raw pixel to use with VGAControllerClass.setRawPixel. ">VGAControllerClass.createRawPixel</a>. </p>
<p>A raw pixel (or raw color) is a byte (uint8_t) that contains color information and synchronization signals.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Horizontal pixel position </td></tr>
    <tr><td class="paramname">y</td><td>Vertical pixel position </td></tr>
    <tr><td class="paramname">rgb</td><td>Raw pixel color</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><pre class="fragment">// Set color of pixel at 100, 100
VGAController.setRawPixel(100, 100, VGAController.createRawPixel(RGB(3, 0, 0));</pre> 
</div>
</div>
<a id="ac190a844ead4bb68817c733fb0c9a5af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac190a844ead4bb68817c733fb0c9a5af">&#9670;&nbsp;</a></span>setResolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fabgl::VGAControllerClass::setResolution </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>modeline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>viewPortWidth</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>viewPortHeight</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doubleBuffered</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets current resolution using linux-like modeline. </p>
<p>Modeline must have following syntax (non case sensitive): </p><pre class="fragment">"label" clock_mhz hdisp hsyncstart hsyncend htotal vdisp vsyncstart vsyncend vtotal (+HSync | -HSync) (+VSync | -VSync) [DoubleScan] [FrontPorchBegins | SyncBegins | BackPorchBegins | VisibleBegins] [MultiScanBlank]
</pre><p>In <a class="el" href="fabglconf_8h.html" title="This file contains FabGL library configuration settings, like number of supported colors...">fabglconf.h</a> there are macros with some predefined modelines for common resolutions. When MultiScanBlank and DoubleScan is specified then additional rows are not repeated, but just filled with blank lines.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modeline</td><td>Linux-like modeline as specified above. </td></tr>
    <tr><td class="paramname">viewPortWidth</td><td>Horizontal viewport size in pixels. If less than zero (-1) it is sized to modeline visible area width. </td></tr>
    <tr><td class="paramname">viewPortHeight</td><td>Vertical viewport size in pixels. If less then zero (-1) it is sized to maximum allocable. </td></tr>
    <tr><td class="paramname">doubleBuffered</td><td>if True allocates another viewport of the same size to use as back buffer. Make sure there is enough free memory.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><pre class="fragment">// Use predefined modeline for 640x480@60Hz
VGAController.setResolution(VGA_640x480_60Hz);

// The same of above using modeline string
VGAController.setResolution("\"640x480@60Hz\" 25.175 640 656 752 800 480 490 492 525 -HSync -VSync");

// Set 640x382@60Hz but limit the viewport to 640x350
VGAController.setResolution(VGA_640x382_60Hz, 640, 350);</pre> <dl><dt><b>Examples: </b></dt><dd><a class="el" href="_altair8800_2_altair8800_8ino-example.html#a9">Altair8800/Altair8800.ino</a>, <a class="el" href="_ansi_terminal_2_ansi_terminal_8ino-example.html#a2">AnsiTerminal/AnsiTerminal.ino</a>, <a class="el" href="_audio_2_audio_8ino-example.html#a2">Audio/Audio.ino</a>, <a class="el" href="_collision_detection_2_collision_detection_8ino-example.html#a10">CollisionDetection/CollisionDetection.ino</a>, <a class="el" href="_double_buffer_2_double_buffer_8ino-example.html#a1">DoubleBuffer/DoubleBuffer.ino</a>, <a class="el" href="_graphical_user_interface_2_graphical_user_interface_8ino-example.html#a2">GraphicalUserInterface/GraphicalUserInterface.ino</a>, <a class="el" href="_loopback_terminal_2_loopback_terminal_8ino-example.html#a5">LoopbackTerminal/LoopbackTerminal.ino</a>, <a class="el" href="_modeline_studio_2_modeline_studio_8ino-example.html#a53">ModelineStudio/ModelineStudio.ino</a>, <a class="el" href="_mouse_on_screen_2_mouse_on_screen_8ino-example.html#a6">MouseOnScreen/MouseOnScreen.ino</a>, <a class="el" href="_network_terminal_2_network_terminal_8ino-example.html#a5">NetworkTerminal/NetworkTerminal.ino</a>, <a class="el" href="_simple_terminal_out_2_simple_terminal_out_8ino-example.html#a1">SimpleTerminalOut/SimpleTerminalOut.ino</a>, <a class="el" href="_space_invaders_2_space_invaders_8ino-example.html#a39">SpaceInvaders/SpaceInvaders.ino</a>, and <a class="el" href="_v_i_c20_2_v_i_c20_8ino-example.html#a17">VIC20/VIC20.ino</a>.</dd>
</dl>
</div>
</div>
<a id="a7ba7a412c75f41a898929e18dae10353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ba7a412c75f41a898929e18dae10353">&#9670;&nbsp;</a></span>setSprites()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fabgl::VGAControllerClass::setSprites </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>sprites</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the list of active sprites. </p>
<p>A sprite is an image that keeps background unchanged.<br />
 There is no limit to the number of active sprites, but flickering and slow refresh happens when a lot of sprites (or large sprites) are visible.<br />
 To empty the list of active sprites call <a class="el" href="classfabgl_1_1_v_g_a_controller_class.html#a574b90ddf0e243837ea00ff0c3ebc8d6" title="Empties the list of active sprites. ">VGAControllerClass.removeSprites()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sprites</td><td>The list of sprites to make currently active. </td></tr>
    <tr><td class="paramname">count</td><td>Number of sprites in the list.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><pre class="fragment">// define a sprite with user data (velX and velY)
struct MySprite : Sprite {
  int  velX;
  int  velY;
};

static MySprite sprites[10];

VGAController.setSprites(sprites, 10);</pre> <dl><dt><b>Examples: </b></dt><dd><a class="el" href="_collision_detection_2_collision_detection_8ino-example.html#a0">CollisionDetection/CollisionDetection.ino</a>, and <a class="el" href="_space_invaders_2_space_invaders_8ino-example.html#a24">SpaceInvaders/SpaceInvaders.ino</a>.</dd>
</dl>
</div>
</div>
<a id="affb399316e3a45b6b3ae601544dbc3a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affb399316e3a45b6b3ae601544dbc3a9">&#9670;&nbsp;</a></span>shrinkScreen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fabgl::VGAControllerClass::shrinkScreen </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shrinkX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shrinkY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduces or expands screen size by the specified horizontal and vertical offset. </p>
<p>Screen shrinking is performed changing horizontal and vertical Front and Back porchs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shrinkX</td><td>Horizontal offset in pixels. &gt; 0 shrinks, &lt; 0 expands. </td></tr>
    <tr><td class="paramname">shrinkY</td><td>Vertical offset in pixels. &gt; 0 shrinks, &lt; 0 expands.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><pre class="fragment">// Shrink screen by 8 pixels and move by 8 pixels to the left
VGAController.shrinkScreen(8, 0);
VGAController.moveScreen(8, 0);</pre> <dl><dt><b>Examples: </b></dt><dd><a class="el" href="_modeline_studio_2_modeline_studio_8ino-example.html#a59">ModelineStudio/ModelineStudio.ino</a>.</dd>
</dl>
</div>
</div>
<a id="acc8e8edb6d677fed102ca33cb59badf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc8e8edb6d677fed102ca33cb59badf2">&#9670;&nbsp;</a></span>suspendBackgroundPrimitiveExecution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fabgl::VGAControllerClass::suspendBackgroundPrimitiveExecution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suspends drawings. </p>
<p>Suspends drawings disabling vertical sync interrupt.<br />
 After call to <a class="el" href="classfabgl_1_1_v_g_a_controller_class.html#acc8e8edb6d677fed102ca33cb59badf2" title="Suspends drawings. ">suspendBackgroundPrimitiveExecution()</a> adding new primitives may cause a deadlock.<br />
 To avoid it a call to "processPrimitives()" should be performed very often.<br />
 This method maintains a counter so can be nested. </p>

</div>
</div>
<a id="aeb7c2b7881a541405690fe44f4c94be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb7c2b7881a541405690fe44f4c94be6">&#9670;&nbsp;</a></span>writeScreen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fabgl::VGAControllerClass::writeScreen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfabgl_1_1_rect.html">Rect</a> const &amp;&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfabgl_1_1_r_g_b.html">RGB</a> *&#160;</td>
          <td class="paramname"><em>srcBuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes pixels inside the specified rectangle. </p>
<p>Screen writing may occur while other drawings are in progress, so written pixels may be overlapped or mixed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>Screen rectangle to write. To improve performance rectangle is not checked. </td></tr>
    <tr><td class="paramname">srcBuf</td><td>Source buffer. Buffer size must be at least rect.width() * rect.height.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><pre class="fragment">// paint a red rectangle
Canvas.setBrushColor(RGB(3, 0, 0));
Rect rect = Rect(10, 10, 100, 100);
Canvas.fillRectangle(rect);

// wait for vsync (hence actual drawing)
VGAController.processPrimitives();

// read rectangle pixels into "buf"
auto buf = new RGB[rect.width() * rect.height()];
VGAController.readScreen(rect, buf);

// write buf 110 pixels to the reight
VGAController.writeScreen(rect.translate(110, 0), buf);
delete buf;</pre> 
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="vgacontroller_8h_source.html">vgacontroller.h</a></li>
<li>vgacontroller.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>fabgl</b></li><li class="navelem"><a class="el" href="classfabgl_1_1_v_g_a_controller_class.html">VGAControllerClass</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
